name: "Todo Tree Action"
description: "Scans PRs for TODO comments and posts them as a comment"
author: "alexandretrotel"

branding:
  icon: "check-square"
  color: "blue"

inputs:
  github-token:
    description: "GitHub token for posting comments"
    required: true
    default: ${{ github.token }}
  path:
    description: "Path to scan"
    required: false
    default: "."
  tags:
    description: "Comma-separated tags to search for (e.g., TODO,F IXME,BUG,HACK)"
    required: false
    default: ""
  include-patterns:
    description: "Comma-separated file patterns to include (e.g., *.rs,*.ts)"
    required: false
    default: ""
  exclude-patterns:
    description: "Comma-separated file patterns to exclude (e.g., *.min.js,vendor/**)"
    required: false
    default: ""
  changed-only:
    description: "Only scan files changed in this PR"
    required: false
    default: "false"
  new-only:
    description: "Only show NEW TODOs (not present in base branch)"
    required: false
    default: "false"
  fail-on-todos:
    description: "Fail the action if any TODOs are found"
    required: false
    default: "false"
  fail-on-fixme:
    description: "Fail the action if FIXME or BUG comments are found"
    required: false
    default: "false"
  max-todos:
    description: "Maximum number of TODOs allowed before failing (empty = unlimited)"
    required: false
    default: ""
  show-annotations:
    description: "Show TODOs as GitHub annotations on the files"
    required: false
    default: "true"
  max-annotations:
    description: "Maximum number of annotations to show (GitHub limit is 50)"
    required: false
    default: "50"
  post-comment:
    description: "Post a summary comment on the PR"
    required: false
    default: "true"
  comment-header:
    description: "Custom header for the PR comment"
    required: false
    default: "## TODO Summary"

outputs:
  total:
    value: ${{ steps.scan.outputs.total }}
    description: "Total number of TODOs found"
  files_count:
    value: ${{ steps.scan.outputs.files_count }}
    description: "Number of files containing TODOs"
  has_todos:
    value: ${{ steps.scan.outputs.has_todos }}
    description: "Whether any TODOs were found (true/false)"
  json:
    value: ${{ steps.scan.outputs.json }}
    description: "Full JSON output from todo-tree"

runs:
  using: "composite"
  steps:
    - name: Run Todo Tree
      id: scan
      shell: bash
      env:
        INPUT_PATH: ${{ inputs.path }}
        INPUT_TAGS: ${{ inputs.tags }}
        INPUT_INCLUDE_PATTERNS: ${{ inputs.include-patterns }}
        INPUT_EXCLUDE_PATTERNS: ${{ inputs.exclude-patterns }}
        INPUT_CHANGED_ONLY: ${{ inputs.changed-only }}
        INPUT_NEW_ONLY: ${{ inputs.new-only }}
        INPUT_FAIL_ON_TODOS: ${{ inputs.fail-on-todos }}
        INPUT_FAIL_ON_FIXME: ${{ inputs.fail-on-fixme }}
        INPUT_MAX_TODOS: ${{ inputs.max-todos }}
        INPUT_SHOW_ANNOTATIONS: ${{ inputs.show-annotations }}
        INPUT_MAX_ANNOTATIONS: ${{ inputs.max-annotations }}
      run: ${{ github.action_path }}/entrypoint.sh

    - name: Post PR Comment
      if: ${{ inputs.post-comment == 'true' && github.event_name == 'pull_request' }}
      uses: actions/github-script@v7
      with:
        github-token: ${{ inputs.github-token }}
        script: |
          const fs = require('fs');

          // Read the scan results
          let todos;
          try {
            todos = JSON.parse(fs.readFileSync('todos.json', 'utf8'));
          } catch (e) {
            console.log('No todos.json found or invalid JSON');
            return;
          }

          const header = '${{ inputs.comment-header }}';
          const changedOnly = '${{ inputs.changed-only }}' === 'true';
          const newOnly = '${{ inputs.new-only }}' === 'true';

          // Format the comment
          let body = `${header}\n\n`;

          // Add mode indicator
          if (newOnly) {
            body += '> Showing only **new** TODOs introduced in this PR\n\n';
          } else if (changedOnly) {
            body += '> Showing TODOs in **changed files** only\n\n';
          }

          const total = todos.summary?.total || 0;
          const files = todos.files || [];

          if (files.length > 0 && total > 0) {
            body += `Found **${total}** TODO(s) in **${files.length}** file(s):\n\n`;

            // Group by priority/tag for better visualization
            const byTag = {};
            for (const file of files) {
              for (const todo of (file.todos || [])) {
                if (!byTag[todo.tag]) byTag[todo.tag] = [];
                byTag[todo.tag].push({ ...todo, path: file.path });
              }
            }

            // Show summary by tag
            body += '<details>\n<summary>Summary by tag</summary>\n\n';
            body += '| Tag | Count |\n|-----|-------|\n';
            for (const [tag, items] of Object.entries(byTag)) {
              body += `| ${tag} | ${items.length} |\n`;
            }
            body += '\n</details>\n\n';

            // Show details by file
            body += '<details open>\n<summary>Details by file</summary>\n\n';
            for (const file of files) {
              if (file.todos && file.todos.length > 0) {
                body += `#### \`${file.path}\`\n`;
                for (const todo of file.todos) {
                  const priority = todo.priority || 'normal';
                  const icon = priority === 'high' ? 'ðŸ”´' : priority === 'medium' ? 'ðŸŸ¡' : 'ðŸ”µ';
                  body += `- ${icon} **${todo.tag}** (L${todo.line}): ${todo.text}\n`;
                }
                body += '\n';
              }
            }
            body += '</details>\n';
          } else {
            body += 'No TODOs found!\n';
          }

          // Add footer with timestamp
          body += `\n---\n<sub>Last updated: ${new Date().toISOString()}</sub>`;

          // Find existing comment to update
          const { data: comments } = await github.rest.issues.listComments({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: context.issue.number,
          });

          const botComment = comments.find(c =>
            c.body.includes(header) && c.user.type === 'Bot'
          );

          if (botComment) {
            await github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: botComment.id,
              body
            });
            console.log('Updated existing comment');
          } else {
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body
            });
            console.log('Created new comment');
          }
